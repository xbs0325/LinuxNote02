[TOC]

# linux环境下编写c



# vim

vim 文件名 打开或创建

命令模式 编辑模式 末行模式

命令模式下

shift+zz保存退出

 

## 1. 切换到编辑模式

i 光标位置当前处插入文字

I 光标所在行行首插入文字

o 光标下一行插入文字

O 光标上一行插入文字

a 光标位置右边插入文字（append）

A 光标所在行行尾插入文字

s 删除光标后字符，从当前位置插入

S 删除当前行在行首插入



## 2. 命令行模式

### 2.2 光标移动

| 按键       | 功能                  |
| ---------- | --------------------- |
| ctrl + f   | 向前滚动一个屏幕      |
| ctrl + b   | 向后滚动一个屏幕      |
| gg         | 到文件第一行行首      |
| G          | 到文件最后一行行首    |
| mG或mgg    | 到指定行，m为目标行数 |
| 0（数字）  | 光标移动到行首        |
| $          | 光标移动到行尾        |
| l（小写L） | 向右移动光标          |
| h          | 向左移动光标          |
| k          | 向上移动光标          |
| j          | 向下移动光标          |
| ^          | 光标移动到行首        |

### 2.3 复制粘贴

| 按键  | 功能                       |
| ----- | -------------------------- |
| [n]yy | 复制从当前行开始的n行      |
| p     | 把粘贴板的内容插入到当前行 |

### 2.4 删除

| 按键  | 功能                                               |
| ----- | -------------------------------------------------- |
| [n]x  | 删除光标后n个字符                                  |
| [n]X  | 删除光标前的n个字符                                |
| D     | 删除光标所在开始到行尾的字符                       |
| [n]dd | 删除从当前开始的n行                                |
| dG    | 删除光标所在开始到文件尾的所有字符                 |
| dw    | 删除光标开始位置的子，包括光标所在字符             |
| d0    | 删除光标本行所有内容，不包含光标所在字符           |
| dgg   | 删除光标所在开始到文件首行第一个字符开始的所有字符 |

其实不是删除 为剪切 不粘贴即为删除

### 2.5 撤销恢复

| 按键     | 功能              |
| -------- | ----------------- |
| .        | 执行上一次此操作  |
| u        | 撤销前一个命令    |
| ctrl + r | 反撤销            |
| 100 + .  | 执行上次操作100次 |

### 2.6 查找

| 按键    | 功能                                    |
| ------- | --------------------------------------- |
| /字符串 | 从当前光标位置向下查找(n,N查找内容切换) |
| ?字符串 | 从当前光标位置向上查找(n,N查找内容切换) |

### 2.7 替换

| 按键 | 功能                                    |
| ---- | --------------------------------------- |
| r    | 替换当前字符                            |
| R    | 替换当前行光标后的字符(ESC退出替换模式) |

### 2.8 可视模式

| 按键      | 功能                                                       |
| --------- | ---------------------------------------------------------- |
| v         | 按字符移动，选中文本，可配合hjkl选择内容，使用d剪切，y复制 |
| shift + v | 行选                                                       |
| ctrl + v  | 列选                                                       |
|           |                                                            |



## 3. 命令模式

### 3.1 保存退出

| 按键        | 功能                           |
| ----------- | ------------------------------ |
| :wq         | 保存退出                       |
| :x          | 保存退出                       |
| :w filename | 保存到指定文件                 |
| :q          | 退出，如果文件修改但是没有保存 |
| :q!         | 退出，不保存                   |

**注 :X为加密 要注意大小写**



### 3.2 替换

| 按键             | 功能                             |
| ---------------- | -------------------------------- |
| :s/abc/123       | 光标所在的第一个abc替换为123     |
| :s/abc/123/g     | 光标所在行的所有abc替换为123     |
| :1,10s/abc/123/g | 将第一行到第10行的abc都替换为123 |
| :%s/abc/123/g    | 当前文件的所有abc都替换为123     |
| :%s/abc/123/gc   | 同上，但是每次替换都需要用户确认 |
| :1,$s/abc/123/g  | 当前文件的所有abc替换为123       |



### 3.3 分屏

| 按键               | 功能                         |
| ------------------ | ---------------------------- |
| :sp                | 当前文件水平分屏             |
| :vsp               | 当前文件垂直分屏             |
| :sp 文件名         | 当前文件和另一个文件水平分屏 |
| :vsp 文件名        | 当前文件和另一个文件垂直分屏 |
| ctrl+w+w           | 在多个窗口切换光标           |
| :wall/:wqall/:qall | 保存/保存退出/退出所有分窗口 |
| vim -O a.c b.c     | 垂直分屏                     |
| vim -o a.c b.c     | 水平分屏                     |



### 3.4 其余指令

| 按键                          | 功能                                |
| ----------------------------- | ----------------------------------- |
| :!man 3 printf                | 在vim中执行命令 man 3 printf        |
| :r !ls -l                     | 将 ls -l 执行的结果写入当前文件中   |
| :r /etc/password              | 将/etc/password文件内容写入         |
| :w /tmp/txt                   | 将当前文件内容写入/tmp/txt          |
| :w! /tmp/txt                  | 强制将当前文件写入/tmp/txt          |
| :1,10s/^/\/\/g                | 将第1行到第10行行首添加// ^代表行首 |
| :1,10s#^#//#g                 | 将第1行到第10行行首添加// ^代表行首 |
| :%s/;/\r{\r\treturn 0;\r}\r/g | 将;替换为return0                    |
| :1,10s#//##g                  | 将第1行到第10行行首的//删除         |



## 4. gcc 编译

### 4.1 编译过程



hello.c	->	hello.i	->	hello.s	->	hello.o	->	hello



### 4.2 gcc 选项

| 选项              | 作用                       |
| ----------------- | -------------------------- |
| -o file           | 指定生成的输出文件名为file |
| -E                | 只进行预处理               |
| -S                | 值进行预处理和编译         |
| -c（小写）        | 只进行预处理、编译、汇编   |
| -v / -version     | 查看gcc版本号              |
| -g                | 包含调试信息               |
| -On （n = 0 - 3） | 编译优化，n越大优化的越多  |
| -Wall             | 提示更多的警告信息         |
| -D                | 编译时定义宏               |

显示所有的警告信息

`gcc -Wall test.c`

将警告信息当作错误处理

`gcc -Wall -Werror test.c`



### 4.3 静态链接和动态链接

gcc test.c -o test_share 动态链接

gcc test.c -o test_static 静态链接



#### 包含静态库的源文件如何编译 gcc *.c

静态库命名规则 libxxx.a

如何打包静态库

```
gcc -c xxx.c -o xxx.o

...

...

ar -rcs libxxx.a xxx.o xxx.o xxx.o
```

r 更新

c 建立

s 创建索引

.a和头文件要放在一起



`gcc test.c -I./(头文件路径) -L./(库的路径) -ltest`



#### 动态库

命名规则

libxxx.so



**1)生成（与地址无关的）目标文件 xxx.o**

`gcc -fpic -c `



**2)链接**

`gcc -shared xxx.o xxx.o xxx.o -o libxxx.so`



**3)编译文件**

文件夹里要有库文件 头文件 还有主要的.c文件 

`gcc libaa.c -L. -I. -laa`



**通过nm命令查看函数**

`nm libxxx.so ｜ grep add`

ldd查看可执行文件依赖的的动态库



**但动态库的链接找不到.so文件 会报错**

所以有以下解决方法

1. 删去-L 将库文件复制到/lib中（不可和原库文件重名）

2. 临时设置

   `export LD_LIBRARY_PATH=＄LD_LIBARARY_PATH:库路径(追加)`

3. 永久设置

（自动运行）

把上述命令加到 ～/.bashrc中

然后source -/.bashrc

4. 永久设置2）

加到链接器的配置文件中

`sudo vim /etc/ld.so.conf`

`sudo ldconfig -v`

5. 符号链接

sudo ln -s 原路径 /libaa.so lib/libaa.so

## 5. 调试

### 5.1 生成调试信息

一般来说GDB主要调试的是C/C++的程序，要调试C/C++的程序，首先要在编译中，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的-g参数可以做到这一点

```
gcc -g hello.c -o hello
g++ -g hello.cpp -o hello
```

如果没有-g，你将看不见程序的函数名，变量名，所代替的全是运行时的内存地址。

### 5.2 启动GDB

* 启动gdb: gdb program

  program 也就是你的执行文件，一般在当前目录下

  

* 设置运行参数

  set args 可指定运行时的参数。（如：set args 10 20 30 40 50）

  show args 命令可以查看设置好的运行参数



* 启动程序

  run: 程序开始执行，如果有断点，停在第一个断点处

  startL: 程序向下执行一行

  

**注：可以在编译时设定变量的值**

gcc xxx.c -Dsize=10 

(注: 可以不定义变量 直接在外部声明宏 在内部使用)

### 5.3 断点

#### 5.3.1 设断点

break line  例 b 10

break func 例 b main

b filename:linenum 例: b hello 10

b filename:functiob 例: b hello main



**C++中**

b class::function

b namespce::class::function

#### 5.3.2 显示断点

info break

i b

#### 5.3.3 设条件断点

b test.c:8 if value == 3

第八行的value值为8时暂停

#### 5.3.4 维护断点

1）delete [range..]删除指定的断点 可简写为d

* 如果不指定断点，则删除所有断点。range表示断点的范围
* 比删除更好的一种方法是disable停止断点 再次使用时用enable就可以了

2）disable [range..] 使指定的断点无效，简写为dis

​	如果什么都不指定 表示disable所有的停止点

3）enable [range..]使无效断点生效，简写为ena

​	如果什么的不指定 表示enable所有的停止点

### 5.4 调试代码

* run 运行程序，可简写为r
* next 单步运行，函数调用当作一条简单语句执行，可简写为n
* step单步跟踪，函数进入被调函数内部，可简写为s
* finish退出当前的函数
* until 在一个循环体内单步跟踪时，这个命令可以运行程序知道退出循环体，可简写为u
* continue继续运行到下一个断点
* quit 退出gdb，可简写为q
* print 查看数据，可简写为p
* ptype 查看类型

 

## Makefile

## 1. 语法规则

`vim Makefile`

```
目标:依赖文件表

<Tab>命令列表
```

退出文件后

`make`

## 2. make

### 2.1 概述

make是一个命令工具，他解释Makefile中的指令

### 2.2 make命名格式

​	make \[-f file\]\[option\][targets]

#### 2.2.1 [-f file]

* make默认在工作目录中寻找名为GNUmakefile、makefile、Makefile的文件作为makefile输入文件
* -f可以指定以上名字以外的文件作文makefile输入文件

#### 2.2.2 [options]

* -v 显示make工具的版本信息
* -w 在处理makefile之前和之后显示工作路径
* -C dir 读取makefile之前改变工作路径至dir目录
* -n 只打印要执行的命令但不执行
* -s 执行但不显示执行的命令

#### 2.2.3 [targets]

* 若使用make命令时没有指定目标，则make工具会默认实现Makefile文件中的第一个目标，然后退出
* 指定了make工具要实现的目标，目标可以是一个或者多个（多个目标之间用空格隔开）。

### 2.3 makefile中变量

1. 类似c中宏定义

2. 一般在头部定义 也可以在任意地方定义

3. 可以数字开头

4. 使用：变量名 = 变量值

  引用：＄（变量名）



### 2.4 makefile模式规则

**将所有.c文件编译为.o文件**

%.o:%.c

​	gcc -c $^ -o $@

**获取所有.c文件函数:**

SRC = $(wildcard ./*.c)

**匹配替换**

OBJ = $(patsubst %.c ,%.o ,$(SRC))



```
SRC = $(wildcard *.c)
OBJS = $(patsubst %.c,%.o,$(SRC))
TARGET = test

$(TARGET):$(OBJS)
	GCC $(OBJS) -o $(TARGET)
	
%.o:%.c
	gcc -c $^ -o $@
```

## 常用报错工具

errno是一个全局变量 在errno.h文件中有定义

errno是保存系统最近出错错误码(整数类型)

strerror函数 传入errno可以返回具体错误(字符串类型)

perror(“字符串”) 输出字符串: 具体错误

